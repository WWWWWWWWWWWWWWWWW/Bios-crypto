Tools for manipulating OLPC keys and signatures

Make a lease:

  Usage:    ./make-lease.sh <sn>  <uuid>  <days>  [outfile]
  Example:  ./make-lease.sh SHF706002A7 8BF9AC40-26F8-4BCC-A699-BE51FD366419 1 lease.sig

  If outfile is omitted, output goes to stdout

Make a developer key:

  Usage:    ./make-devkey.sh sn uuid [outfile]
  Example:  ./make-devkey.sh SHF706002A7 8BF9AC40-26F8-4BCC-A699-BE51FD366419 develop.sig

  If outfile is omitted, output goes to stdout

Sign a kernel or initrd image file:

  Usage:    ./sign-os keyname infile outfile.zip
  Example:  ./sign-os  os  vmlinuz  runos.zip
            ./sign-os  os  initrd   runrd.zip

Sign a firmware file:

  Usage:    ./sign-fw keyname infile outfile.zip
  Example:  ./sign-fw  fw  q2c25.rom  bootfw.zip

Lower level tools:

Calculate a future date in the stipulated format:

  Usage:    ./futureday.py days
  Example:  ./futureday.py 5

  Output goes to stdout

Create a sig01-format signature blob:

  Usage:    ./sig01 hashname keyname infile
  Example:  ./sig01 sha256 fw q2c25.rom
            ./sig01 rmd160 fw q2c25.rom

  Output goes to stdout

Make an RSA-2048 key pair:

  Usage:    ./makekey key_file_name
  Example:  ./makekey os

  Output goes to key_file_name.public and key_file_name.private

Create a binary signature file:

  Usage:    ./sign hashname key_file_name signed_file_name
  Example:  ./sign sha256 os vmlinuz

  The signing key is key_file_name.private
  Output goes to signed_file_name.hashname.sig

Verify a binary signature file:

  Usage:    ./verify hashname key_file_name signed_file_name
  Example:  ./verify sha256 os vmlinuz

  The signature file name is signed_file_name.hashname.sig
  The verification key is key_file_name.public
